# ado-pipeline-templates/stages/cd.yml
parameters:
- name: env
  type: string
  default: dev
- name: vmImage
  type: string
  default: ubuntu-latest
- name: artifact_name
  type: string
  default: drop
- name: service_connection
  type: string
  default: ''            # if empty, AzureCLI step is omitted
- name: var_groups
  type: object
  default: []            # e.g., ['app-qa']

stages:
- stage: Deploy_${{ parameters.env }}
  displayName: "Deploy to ${{ parameters.env }}"
  dependsOn: CI
  condition: succeeded()                # ‚Üê only one condition at stage level

  variables:
  - ${{ each g in parameters.var_groups }}:
    - group: ${{ g }}

  jobs:
  - deployment: deploy_${{ parameters.env }}
    displayName: "Deploy (${{ parameters.env }})"
    environment: ${{ parameters.env }}  # ADO Environment name (dev/qa/prod)
    pool:
      vmImage: ${{ parameters.vmImage }}
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: none

          # Download artifact from the CURRENT run
          - download: current
            artifact: ${{ parameters.artifact_name }}
            displayName: "Download artifact (current run)"

          # Inspect (handy while wiring up)
          - script: |
              echo "Artifact path:"
              ls -la "$(Pipeline.Workspace)/${{ parameters.artifact_name }}" || true
            displayName: "Inspect artifact"

          # Only include Azure CLI step if a connection name is provided
          - ${{ if ne(parameters.service_connection, '') }}:
            - task: AzureCLI@2
              displayName: "Deploy (placeholder)"
              inputs:
                azureSubscription: ${{ parameters.service_connection }}
                scriptType: bash
                scriptLocation: inlineScript
                inlineScript: |
                  echo "Deploying to ${{ parameters.env }}"
                  echo "From: $(Pipeline.Workspace)/${{ parameters.artifact_name }}"
                  # TODO: add real az commands here
